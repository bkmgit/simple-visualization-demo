/* A program to solve the real 2 dimensional cubic Klein Gordon equation
 * u_tt = u^3 - u + u_xx + u_yy
 * on the domain [0,2\pi)^2 using the leap frog time
 * stepping scheme
 * u_[n+1] = 2u_n - u_[n-1] + (dt^2)*((u_n)^3 -u_n + \Delta*(u_n)
 * and a second order finite difference scheme in space
 * where
 * \Delta u_n = (u_[n,i+1,j] - 2*u_[n,i,j] + u_[n,i-1,j])/(dx^2)
 *             +(u_[n,i,j+1] - 2*u_[n,i,j] + u_[n,i,j-1])/(dy^2)
 *
 * Images generated by insitu visualization are in
 * plain pgm format, which is documented at
 * 
 * http://netpbm.sourceforge.net/doc/pgm.html
 *
 * Compile the program using 
 *    gcc wave2d.c -lm
 */

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>

#define nt 60
#define nx 64
#define ny 64
#define pi 3.141592653589793
int main()
{
        float *x;
        float *y;
        float *unew;
        float *u;
        float *uold;
        unsigned char *vizimage;
        float dx=2*pi/nx;
        float dy=2*pi/ny;
        float dt=0.05;
        float umax;
        float umin;
        char fname[100];
        FILE * fid;

        // create memory
        x=(float*)calloc(nx,sizeof(float));
        y=(float*)calloc(ny,sizeof(float));
        unew=(float*)calloc(nx*ny,sizeof(float));
        u=(float*)calloc(nx*ny,sizeof(float));
        uold=(float*)calloc(nx*ny,sizeof(float));
        vizimage=(unsigned char*)calloc(nx*ny,sizeof(unsigned char));

        // setup grid
        for(int i=0;i<nx;i++) x[i]=i*dx;
        for(int j=0;j<ny;j++) y[j]=j*dy;

        // setup initial data
        for(int j=0;j<ny;j++)
        {
                for(int i=0;i<nx;i++) 
                {
                        u[i+j*nx]=sin(i*dx)*cos(2*j*dy);
                        uold[i+j*nx]=sin(i*dx)*cos(2*j*dy);
                }
        }

        // do timestepping
        // loop is unrolled to minimize copies
        for(int n=0;n<nt/3;n++)
        {
                for(int j=0;j<ny;j++)
                {
                        int jplus=(j+1)%ny;
                        int jminus=(j+ny-1)%ny;
                        for(int i=0;i<nx;i++)
                        {
                                int iplus=(i+1)%nx;
                                int iminus=(i+nx-1)%nx;
                                unew[i+j*nx]=2*u[i+j*nx]-uold[i+j*nx]
                                        +dt*dt*(u[i+j*nx]*u[i+j*nx]*u[i+j*nx] - u[i+j*nx]
                                                +(u[iplus+j*nx]-2*u[i+j*nx]+u[iminus+j*nx])/(dx*dx)
                                                +(u[i+jplus*nx]-2*u[i+j*nx]+u[i+jminus*nx])/(dy*dy));
                        }
                }


                for(int j=0;j<ny;j++)
                {
                        int jplus=(j+1)%ny;
                        int jminus=(j+ny-1)%ny;
                        for(int i=0;i<nx;i++)
                        {
                                int iplus=(i+1)%nx;
                                int iminus=(i+nx-1)%nx;
                                uold[i+j*nx]=2*unew[i+j*nx]-u[i+j*nx]
                                        +dt*dt*(unew[i+j*nx]*unew[i+j*nx]*unew[i+j*nx] - unew[i+j*nx]
                                               +(unew[iplus+j*nx]-2*unew[i+j*nx]+unew[iminus+j*nx])/(dx*dx)
                                               +(unew[i+jplus*nx]-2*unew[i+j*nx]+unew[i+jminus*nx])/(dy*dy));
                        }
                                        
                }

                // initialize to scale image
                umax=-1000;
                umin= 1000;
                for(int j=0;j<ny;j++)
                {
                        int jplus=(j+1)%ny;
                        int jminus=(j+ny-1)%ny;
                        for(int i=0;i<nx;i++)
                        {
                                int iplus=(i+1)%nx;
                                int iminus=(i+nx-1)%nx;
                                u[i+j*nx]=2*uold[i+j*nx]-unew[i+j*nx]
                                        +dt*dt*(uold[i+j*nx]*uold[i+j*nx]*uold[i+j*nx] - uold[i+j*nx]
                                              +(uold[iplus+j*nx]-2*uold[i+j*nx]+uold[iminus+j*nx])/(dx*dx)
                                              +(uold[i+jplus*nx]-2*uold[i+j*nx]+uold[i+jminus*nx])/(dy*dy));
                                if(u[i+j*nx]>umax) umax=u[i+j*nx];
                                if(u[i+j*nx]<umin) umin=u[i+j*nx];
                        }
                }
                // write out data to image file in pgm format
                sprintf(fname,"image%d.pgm",n);
                fid = fopen(fname,"w");
                fprintf(fid,"P2\n");
                fprintf(fid,"#Data from timestep %d with maximum %f and minimum %f\n",n,umax,umin);
                fprintf(fid,"%d %d\n",nx,ny);
                if(umax==umin) 
                        fprintf(fid,"0\n");
                else
                        fprintf(fid,"255\n");
                for(int j=0;j<ny;j++)
                {
                        for(int i=0;i<nx;i++)
                        {
                                // prevent division by zero and add a small visualization error
                                unsigned char temp = (unsigned char) 
                                        (round(255*(u[i+j*nx]-umin)/(umax-umin +0.000001)));
                                fprintf(fid,"%hhu\n",temp);
                        }
                }
                fclose(fid);
        }
        // free memory
        free(unew);
        free(u);
        free(uold);
        free(x);
        free(y);

        return 0;
}
