/* 
 * A program to solve the real 2 dimensional cubic Klein Gordon equation
 * u_tt = u^3 - u + u_xx + u_yy
 * on the domain [0,2\pi)^2 using the leap frog time
 * stepping scheme
 * u_[n+1] = 2u_n - u_[n-1] + (dt^2)*((u_n)^3 -u_n + \Delta*(u_n)
 * and a second order finite difference scheme in space
 * where
 * \Delta u_n = (u_[n,i+1,j] - 2*u_[n,i,j] + u_[n,i-1,j])/(dx^2)
 *             +(u_[n,i,j+1] - 2*u_[n,i,j] + u_[n,i,j-1])/(dy^2)
 *
 * Images generated by insitu visualization are
 * stored in a custom compressed pgm format. The
 * regular pgm header is saved as a text file, and
 * the numerical data is compressed using the
 * ranged Asymmetric Numeral System for an alphabet of
 * 256 letters using a base of 512 and saved in 
 * a binary file
 * 
 * The program has a dependency on [LibTomMath](http://www.libtom.net/LibTomMath/)
 *
 * References
 *
 * [0] https://en.wikipedia.org/wiki/Asymmetric_numeral_systems
 *
 * [1] M. Simisker "A Review of Asymmetric Numeral Systems"
 * https://courses.cs.ut.ee/MTAT.07.022/2017_fall/uploads/Main/mart-report-f17.pdf
 *
 * [2] J. Gibbons "Coding with Asymmetric Numeral Systems (long version)"
 * http://www.cs.ox.ac.uk/jeremy.gibbons/publications/asymm-long.pdf
 *
 * [3] R. Cheplyaka "Understanding Asymmetric Numeral Systems"
 * https://ro-che.info/articles/2017-08-20-understanding-ans
 *
 * [4] J. Duda "Asymmetric numeral systems: entropy coding combining speed of
 * Huffman coding with compression rate of arithmetic coding"
 * https://arxiv.org/abs/1311.2540
 *
 * [5] J. Duda "Asymmetric Numeral Systems"
 * https://arxiv.org/abs/0902.0271
 *
 * [6] https://gist.github.com/reaandrew/21c0bbcc75086c72edfd
 *
 * [7] https://en.wikipedia.org/wiki/Bitwise_operations_in_C
 *
 * [8] http://netpbm.sourceforge.net/doc/pgm.html
 *
 * Compile the program using 
 *    gcc wave2dplusans.c -lm libtommath.a
 */

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include <unistd.h>
#include <inttypes.h>
#include "tommath.h"

#define maxnumsymbols 256
#define m 512 // need m >= numsymbols, power of 2 makes for easy division
#define nt 15 // should be divisible by 3 due to loop unrolling
#define nx 64
#define ny 64
#define pi 3.141592653589793
#define dt 0.05
int main()
{
        float *x;
        float *y;
        float *unew;
        float *u;
        float *uold;
        unsigned char *vizimage;
        float dx=2*pi/nx;
        float dy=2*pi/ny;
        float umax;
        float umin;
        char fname[100];
        FILE * fid;
        unsigned char *numtosymbol;
        unsigned char *symboltonum;
        unsigned char *symbolsin;
        unsigned int *symbolpresent;
        unsigned int *ls;  // length of symbols range
        unsigned int *s;
        unsigned int *bs; // beginning of symbols range
        unsigned int numsymbols=0;
        unsigned char symbolcount=0;
        unsigned char count=0;
        size_t numbytes;
        uint8_t *outbuf;
        mp_int xmp;
        mp_int tmpmp;
        mp_int lsmp;
        mp_int bsmp;
        mp_int mmp;
        mp_err result;

        // allocate memory space
        if ((result = mp_init_size(&xmp, 10000)) != MP_OKAY) {
                printf("Error initializing the number.  %s",
                                mp_error_to_string(result));
                return 1;
        }
        if ((result = mp_init_size(&tmpmp, 10000)) != MP_OKAY) {
                printf("Error initializing the number.  %s",
                                mp_error_to_string(result));
                return 1;
        }
        if ((result = mp_init_multi(&lsmp,&bsmp,&mmp, NULL)) != MP_OKAY) {
                printf("Error initializing the numbers.  %s",
                                mp_error_to_string(result));
                return 1;
        }

        mp_set_u32(&mmp,(unsigned int) m);

        x=(float*)calloc(nx,sizeof(float));
        y=(float*)calloc(ny,sizeof(float));
        unew=(float*)calloc(nx*ny,sizeof(float));
        u=(float*)calloc(nx*ny,sizeof(float));
        uold=(float*)calloc(nx*ny,sizeof(float));
        vizimage=(unsigned char*)calloc(nx*ny,sizeof(unsigned char));
        numtosymbol=(unsigned char*)calloc(maxnumsymbols,sizeof(unsigned char));
        symboltonum=(unsigned char*)calloc(maxnumsymbols,sizeof(unsigned char));
        symbolsin=(unsigned char*)calloc(nx*ny,sizeof(unsigned char));
        symbolpresent=(unsigned int *)calloc(maxnumsymbols,sizeof(unsigned int));
        ls=(unsigned int *)calloc(maxnumsymbols,sizeof(unsigned int));
        s=(unsigned int *)calloc(m,sizeof(unsigned int));
        bs=(unsigned int *)calloc(maxnumsymbols,sizeof(unsigned int));
        outbuf=(uint8_t *)malloc(8000*sizeof(uint8_t));
        printf("Allocated memory\n");
        // setup grid
        for(unsigned int i=0;i<nx;i++) x[i]=i*dx;
        for(unsigned int j=0;j<ny;j++) y[j]=j*dy;

        // setup initial data
        for(unsigned int j=0;j<ny;j++)
        {
                for(unsigned int i=0;i<nx;i++) 
                {
                        u[i+j*nx]=sin(i*dx)*cos(2*j*dy);
                        uold[i+j*nx]=sin(i*dx)*cos(2*j*dy);
                }
        }
        printf("Setup initial data and grid, starting timestepping\n");
        // do timestepping
        // loop is unrolled to minimize copies
        for(unsigned int n=0;n<nt/3;n++)
        {
                for(unsigned int j=0;j<ny;j++)
                {
                        unsigned int jplus=(j+1)%ny;
                        unsigned int jminus=(j+ny-1)%ny;
                        for(unsigned int i=0;i<nx;i++)
                        {
                                unsigned int iplus=(i+1)%nx;
                                unsigned int iminus=(i+nx-1)%nx;
                                unew[i+j*nx]=2*u[i+j*nx]-uold[i+j*nx]
                                        +dt*dt*(u[i+j*nx]*u[i+j*nx]*u[i+j*nx] - u[i+j*nx]
                                                +(u[iplus+j*nx]-2*u[i+j*nx]+u[iminus+j*nx])/(dx*dx)
                                                +(u[i+jplus*nx]-2*u[i+j*nx]+u[i+jminus*nx])/(dy*dy));
                        }
                }


                for(unsigned int j=0;j<ny;j++)
                {
                        unsigned int jplus=(j+1)%ny;
                        unsigned int jminus=(j+ny-1)%ny;
                        for(unsigned int i=0;i<nx;i++)
                        {
                                unsigned int iplus=(i+1)%nx;
                                unsigned int iminus=(i+nx-1)%nx;
                                uold[i+j*nx]=2*unew[i+j*nx]-u[i+j*nx]
                                        +dt*dt*(unew[i+j*nx]*unew[i+j*nx]*unew[i+j*nx] - unew[i+j*nx]
                                               +(unew[iplus+j*nx]-2*unew[i+j*nx]+unew[iminus+j*nx])/(dx*dx)
                                               +(unew[i+jplus*nx]-2*unew[i+j*nx]+unew[i+jminus*nx])/(dy*dy));
                        }
                                        
                }

                // initialize to scale image
                umax=-1000;
                umin= 1000;
                for(unsigned int j=0;j<ny;j++)
                {
                        unsigned int jplus=(j+1)%ny;
                        unsigned int jminus=(j+ny-1)%ny;
                        for(unsigned int i=0;i<nx;i++)
                        {
                                unsigned int iplus=(i+1)%nx;
                                unsigned int iminus=(i+nx-1)%nx;
                                u[i+j*nx]=2*uold[i+j*nx]-unew[i+j*nx]
                                        +dt*dt*(uold[i+j*nx]*uold[i+j*nx]*uold[i+j*nx] - uold[i+j*nx]
                                              +(uold[iplus+j*nx]-2*uold[i+j*nx]+uold[iminus+j*nx])/(dx*dx)
                                              +(uold[i+jplus*nx]-2*uold[i+j*nx]+uold[i+jminus*nx])/(dy*dy));
                                if(u[i+j*nx]>umax) umax=u[i+j*nx];
                                if(u[i+j*nx]<umin) umin=u[i+j*nx];
                        }
                }

                // Get image data to write out
                for(unsigned int j=0;j<ny;j++)
                {
                        for(unsigned int i=0;i<nx;i++)
                        {
                                // prevent division by zero and add a small visualization error
                                vizimage[i+j*nx] = (unsigned char)
                                        (round(255*(u[i+j*nx]-umin)/(umax-umin +0.000001)));
                        }
                }
                // Count number of symbols for compression 
                numsymbols=0;
                symbolcount=0;
                count=0;
                for(unsigned int i=0;i<maxnumsymbols;i++) symbolpresent[i]=0;
                for(unsigned int i=0;i<nx*ny;i++) symbolpresent[vizimage[i]]=1;
                for(unsigned int i=0;i<maxnumsymbols;i++) numsymbols+=symbolpresent[i];
                for(unsigned int i=0;i<maxnumsymbols;i++)
                {
                        if(symbolpresent[i]==1) 
                        {
                                numtosymbol[i]=symbolcount++;
                                symboltonum[count++]=i;
                        }else{
                                numtosymbol[i]=255;
                        }
                }
                // Get symbols from numbers in
                for(unsigned int i=0;i<nx*ny;i++) symbolsin[i]=numtosymbol[vizimage[i]];
                // initialize encoding arrays
                for(unsigned int i=0;i<numsymbols;i++)
                {
                        ls[i]=0;
                        bs[i]=0;
                }
                for(unsigned int i=0;i<m;i++) s[i]=0;
                // Setup encoding tables
                for(unsigned int i=0;i<nx*ny;i++) ls[symbolsin[i]]++;
                bs[0]=0;
                for(unsigned int i=1;i<numsymbols;i++) bs[i]=bs[i-1]+ls[i-1];
                for(unsigned int j=0;j<m;j++)
                {
                        unsigned long long thissum = 0;
                        for(unsigned int i=0;i<=j;i++) 
                        {
                                thissum += ls[i];
                                if(thissum>j)
                                {
                                        s[j]=i;
                                        break;
                                }
                        }
                }
                // Encode
                for(unsigned int i=0;i<nx*ny;i++)
                {
                        unsigned int st = symbolsin[i];
                        //x = m*(x/ls[st]) + bs[st] + x%ls[st];
                        mp_set_u32(&lsmp,(unsigned int) ls[st]);
                        mp_set_u32(&bsmp,(unsigned int) bs[st]);
                        result = mp_div(&xmp,&lsmp,&xmp,&tmpmp);
                        result = mp_mul(&xmp,&mmp,&xmp);
                        result = mp_add(&xmp,&bsmp,&xmp);
                        result = mp_add(&xmp,&tmpmp,&xmp);
                }
                // write out compressed data
                result = mp_to_ubin(&xmp, outbuf, 8000, &numbytes);
                sprintf(fname,"data%u.pgmb",n);
                fid = fopen(fname,"wb");
                fwrite(outbuf,1,numbytes,fid);
                //result = mp_fwrite(&xmp,10,fid);
                fclose(fid);

                // write out data header for image file (header uses pgm format)
                sprintf(fname,"image%u.pgmh",n);
                fid = fopen(fname,"w");
                fprintf(fid,"P2\n");
                fprintf(fid,"#Data from timestep %u with maximum %f and minimum %f\n",n,umax,umin);
                fprintf(fid,"#symboltonum ");
                for(unsigned int i=0;i<count;i++) fprintf(fid,"%hhu ", symboltonum[i]);
                fprintf(fid,"\n");
                fprintf(fid,"#ls ");
                for(unsigned int i=0;i<numsymbols;i++) fprintf(fid,"%hhu ", ls[i]);
                fprintf(fid,"\n");
                fprintf(fid,"%u %u\n",nx,ny);
                if(umax==umin) 
                        fprintf(fid,"0\n");
                else
                        fprintf(fid,"255\n");
                fclose(fid);
        }
        printf("Timestepping finished\n");
        // free memory
        free(unew);
        free(u);
        free(uold);
        free(x);
        free(y);
        free(vizimage);
        free(numtosymbol);
        free(symboltonum);
        free(symbolsin);
        free(symbolpresent);
        free(ls);
        free(s);
        free(bs);
        free(outbuf);
        mp_clear(&xmp);
        mp_clear(&tmpmp);
        mp_clear_multi(&lsmp,&bsmp,&mmp,NULL);
        printf("Memory made free\n");

        return 0;
}
